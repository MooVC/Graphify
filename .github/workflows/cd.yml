name: .NET Build, Test & Publish

on:
  push:
    tags:
      - '*'
  workflow_dispatch:
    inputs:
      deprecate_only:
        default: false
        description: 'Run only the deprecate job using artifacts from a previous run.'
        type: boolean
      run_id:
        description: 'Workflow run ID to download artifacts from when deprecate_only is true.'
        required: false
        type: string
      semantic_version:
        description: 'Package version to deprecate against when deprecate_only is true (e.g., 10.0.0-beta.1).'
        required: false
        type: string

env:
  configuration: 'Release'
  NUGET_PACKAGES: ${{ github.workspace }}/.nuget/packages
  PACKAGE_ID: 'Graphify'
  solution: 'Graphify.slnx'

permissions:
  packages: write

jobs:
  build:
    name: Build, Test & Publish
    runs-on: windows-latest
    if: ${{ github.event_name != 'workflow_dispatch' || inputs.deprecate_only != 'true' }}

    outputs:
      semantic: ${{ steps.extract-version.outputs.semantic }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Use .NET SDKs
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: |
            10.0.x

      - name: Cache NuGet Packages
        uses: actions/cache@v5
        with:
          path: ${{ github.workspace }}/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore NuGet Packages
        run: dotnet restore ${{ env.solution }}

      - name: Extract and Format Version from Tag
        id: extract-version
        shell: bash
        run: |
          # If push event with refs/tags, parse that. Otherwise, fallback to describing the last tag found.
          if [[ "$GITHUB_REF" =~ ^refs/tags/ ]]; then
            rawTag="${GITHUB_REF#refs/tags/}"
          else
            rawTag="$(git describe --tags $(git rev-list --tags --max-count=1) 2>/dev/null || echo "")"
          fi

          # If there's no real tag, rawTag might be empty on a manual run
          if [ -z "$rawTag" ]; then
            echo "No tag found - setting semantic=0.0.0"
            semantic="0.0.0"
          else
            # Remove a leading 'v' if present
            semantic="${rawTag#v}"
          fi

          numeric="${semantic%%-*}.0"

          echo "version=$numeric"       >> $GITHUB_ENV
          echo "semantic=$semantic"     >> $GITHUB_ENV
          echo "informational=$rawTag"  >> $GITHUB_ENV
          echo "semantic=$semantic"     >> $GITHUB_OUTPUT

      - name: Build Solution
        run: dotnet build ${{ env.solution }} --configuration ${{ env.configuration }} --no-restore -p:AssemblyVersion=${{ env.version }} -p:FileVersion=${{ env.version }}   -p:InformationalVersion=${{ env.informational }} -p:PackageVersion=${{ env.semantic }} -p:Version=${{ env.version }}

      - name: Test Solution
        run: dotnet test ${{ env.solution }} --configuration ${{ env.configuration }} --no-build

      - name: Upload Code Coverage
        if: ${{ github.event_name == 'push' }}
        uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Pack Solution
        if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_pack_and_publish  == 'true') }}
        run: dotnet pack ${{ env.solution }} --configuration ${{ env.configuration }} --no-build --output ./artifacts -p:Version=${{ env.semantic }}

      - name: Upload Packages
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: ./artifacts/*.nupkg

      - name: Publish Packages to GitHub
        if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_pack_and_publish  == 'true') }}
        run: dotnet nuget push **/${{ env.PACKAGE_ID }}*.nupkg --source "https://nuget.pkg.github.com/MooVC/index.json" --api-key ${{ secrets.GITHUB_TOKEN }} --skip-duplicate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 
      - name: Publish Packages to NuGet
        if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_pack_and_publish  == 'true') }}
        run: dotnet nuget push **/${{ env.PACKAGE_ID }}*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate

  deprecate:
    name: Deprecate Previous Package Versions
    runs-on: windows-latest
    needs: build
    if: ${{ (github.event_name == 'workflow_dispatch' && inputs.deprecate_only == 'true') || needs.build.result == 'success' }}

    steps:
    - name: Use .NET SDKs
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: |
          10.0.x

    - name: Extract and Format Version from Tag
      if: ${{ github.event_name != 'workflow_dispatch' || inputs.deprecate_only != 'true' }}
      run: |
        $rawTag = '${{ github.ref_name }}'
        $semantic = $rawTag -replace '^v', '' -replace '(alpha|beta|rc)0+', '$1.' 
        $numeric = ($semantic -split "-")[0] + ".0"
        
        echo "version=$numeric" >> $env:GITHUB_ENV
        echo "semantic=$semantic" >> $env:GITHUB_ENV
        echo "informational=$rawTag" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Set Version from Inputs
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.deprecate_only == 'true' }}
      run: |
        if (-not '${{ inputs.semantic_version }}') {
          throw 'semantic_version input is required when deprecate_only is true.'
        }

        $semantic = '${{ inputs.semantic_version }}'
        $numeric = ($semantic -split "-")[0] + ".0"

        echo "version=$numeric" >> $env:GITHUB_ENV
        echo "semantic=$semantic" >> $env:GITHUB_ENV
        echo "informational=$semantic" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Download Packages
      if: ${{ github.event_name != 'workflow_dispatch' || inputs.deprecate_only != 'true' }}
      uses: actions/download-artifact@v4
      with:
        name: nuget-packages
        path: ./artifacts

    - name: Download Packages from Previous Run
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.deprecate_only == 'true' }}
      uses: actions/download-artifact@v4
      with:
        name: nuget-packages
        path: ./artifacts
        run-id: ${{ inputs.run_id }}
        repository: ${{ github.repository }}
        github-token: ${{ secrets.GITHUB_TOKEN }}

    - name: Deprecate Previous Versions on NuGet
      env:
        NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
      run: |
        $ErrorActionPreference = 'Stop'
        $currentVersion = '${{ env.semantic }}'
        $packages = Get-ChildItem -Path ./artifacts -Filter *.nupkg
        if (-not $packages) {
          throw 'No NuGet packages found to determine package IDs.'
        }

        Add-Type -AssemblyName System.IO.Compression.FileSystem

        foreach ($package in $packages) {
          $archive = [IO.Compression.ZipFile]::OpenRead($package.FullName)
          try {
            $nuspecEntry = $archive.Entries | Where-Object { $_.FullName -like '*.nuspec' } | Select-Object -First 1
            if (-not $nuspecEntry) {
              throw "Missing nuspec in package $($package.Name)."
            }
            $reader = New-Object IO.StreamReader($nuspecEntry.Open())
            try {
              [xml]$nuspec = $reader.ReadToEnd()
            } finally {
              $reader.Dispose()
            }
          } finally {
            $archive.Dispose()
          }

          $packageId = $nuspec.package.metadata.id
          if (-not $packageId) {
            throw "Unable to determine package ID for $($package.Name)."
          }

          $packageIndexUrl = "https://api.nuget.org/v3-flatcontainer/$($packageId.ToLowerInvariant())/index.json"
          $maxAttempts = 60
          $delaySeconds = 60
          $versions = $null

          for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
            $response = Invoke-RestMethod -Uri $packageIndexUrl -Method Get
            if ($response.versions -contains $currentVersion) {
              $versions = $response.versions
              break
            }

            Write-Host "Waiting $delaySeconds seconds for $packageId $currentVersion to appear on NuGet (attempt $attempt of $maxAttempts)."
            Start-Sleep -Seconds $delaySeconds
          }

          if (-not $versions) {
            throw "Package $packageId $currentVersion did not appear on NuGet after $maxAttempts attempts."
          }

          $currentSemanticVersion = [System.Management.Automation.SemanticVersion]::Parse($currentVersion)
          $parsedVersions = $versions | ForEach-Object { [System.Management.Automation.SemanticVersion]::Parse($_) }
          $candidateVersions = if ($currentSemanticVersion.IsPrerelease) {
            $parsedVersions | Where-Object { $_.IsPrerelease }
          } else {
            $parsedVersions
          }

          $previousVersions = $candidateVersions | Where-Object { $_ -lt $currentSemanticVersion } | Sort-Object -Descending
          if (-not $previousVersions) {
            Write-Host "No previous $packageId versions to deprecate. Skipping deprecation."
            continue
          }
          $registrationIndexUrl = "https://api.nuget.org/v3/registration5-gz-semver2/$($packageId.ToLowerInvariant())/index.json"
          $registrationIndex = Invoke-RestMethod -Uri $registrationIndexUrl -Method Get
          $registrationItems = @()
          foreach ($item in $registrationIndex.items) {
            if ($item.items) {
              $registrationItems += $item.items
            } else {
              $page = Invoke-RestMethod -Uri $item.'@id' -Method Get
              $registrationItems += $page.items
            }
          }

          foreach ($previousVersion in $previousVersions) {
            $previousVersionText = $previousVersion.ToString()
            $previousEntry = $registrationItems | Where-Object { $_.catalogEntry.version -eq $previousVersionText } | Select-Object -First 1
            if (-not $previousEntry) {
              Write-Host "Unable to find registration entry for $packageId $previousVersionText. Skipping deprecation."
              continue
            }

            if (-not $previousEntry.listed) {
              Write-Host "Package $packageId $previousVersionText is unlisted. Skipping deprecation."
              continue
            }

            if ($previousEntry.catalogEntry.deprecation) {
              Write-Host "Package $packageId $previousVersionText is already deprecated. Skipping deprecation."
              continue
            }

            Write-Host "Deprecating $packageId $previousVersionText in favor of $currentVersion."
            $deprecateBody = @{
              isOther = $true
              message = "Deprecated in favor of $currentVersion."
            }
            $headers = @{
              'X-NuGet-Client-Version' = 'MooVC-CD/1.0'
              'X-NuGet-Protocol-Version' = '4.1.0'
              'X-NuGet-ApiKey' = $env:NUGET_API_KEY
            }
            $deprecateUri = "https://www.nuget.org/api/v2/package/{0}/{1}/deprecate" -f $packageId, $previousVersionText
            Invoke-RestMethod -Uri $deprecateUri -Method Put -Headers $headers -UserAgent 'MooVC-CD' -ContentType 'application/x-www-form-urlencoded' -Body $deprecateBody
          }
        }
      shell: pwsh